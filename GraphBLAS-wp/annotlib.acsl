//
//  annotlib.acsl
//  
//  SuiteSparse:GraphBLAS:Verification, Jenna L. Wise, (c) 2018, All Rights Reserved.
//  Created on 7/2/18.
//  Last updated on 7/4/18
//  Predicate and logic functions for GrB structs
//  Ensures encapsulation of the structs' internal representation in the annotations

//  IMPORTANT NOTE TO SELF: null ptr checks for input to checks in GB implementation
//                          occur in the check method implementation
//                          I am also doing ptr checks within _valid predicates with
//                          \valid
//                          makes sense since the ptrs are hidden in the typdef

// TODO: Are the {L} labels correct?

#include "GB.h"

//------------------------------------------------------------------------------
// Common
//------------------------------------------------------------------------------

/*@
 predicate magic_valid(int64_t magic) = magic == 0x00981B0787374E72 ;
 */

//------------------------------------------------------------------------------
// GrB_Type
//------------------------------------------------------------------------------

// no footprint
/*@
 logic int type_code{L}(GrB_Type t) = t->code ;
 
 logic size_t type_size{L}(GrB_Type t) = t->size ;
 
 // TODO: make sure don't need more than magic check
 predicate type_init{L}(GrB_Type t) = magic_valid(t->magic) ;
 
 // TODO: might be able to shorten this because of numbering of enums
 predicate type_code_valid{L}(GrB_Type t) =
    \let c = type_code(t);
        c == GB_BOOL_code   ||
        c == GB_INT8_code   ||
        c == GB_UINT8_code  ||
        c == GB_INT16_code  ||
        c == GB_UINT16_code ||
        c == GB_INT32_code  ||
        c == GB_UINT32_code ||
        c == GB_INT64_code  ||
        c == GB_UINT64_code ||
        c == GB_FP32_code   ||
        c == GB_FP64_code   ||
        c == GB_UDT_code ;
 
 predicate type_size_valid{L}(GrB_Type t) =
    type_size(t) != 0 &&
    (\let c = type_code(t);
        (\let s = type_size(t);
            (c == GB_BOOL_code ?
                s == sizeof(bool) :
            (c == GB_INT8_code ?
                s == sizeof(int8_t) :
            (c == GB_UINT8_code ?
                s == sizeof(uint8_t) :
            (c == GB_INT16_code ?
                s == sizeof(int16_t) :
            (c == GB_UINT16_code ?
                s == sizeof(uint16_t) :
            (c == GB_INT32_code ?
                s == sizeof(int32_t) :
            (c == GB_UINT32_code ?
                s == sizeof(uint32_t) :
            (c == GB_INT64_code ?
                s == sizeof(int64_t) :
            (c == GB_UINT64_code ?
                s == sizeof(uint64_t) :
            (c == GB_FP32_code ?
                s == sizeof(float) :
            (c == GB_FP64_code ?
                s == sizeof(double) :
            (c == GB_UDT_code ?
                s == s :
                \false
            ))))))))))))
        )
    ) ;
 */

/*@
 predicate type_valid{L}(GrB_Type t) =
    \valid(t) &&
    type_init(t) &&
    type_code_valid(t) &&
    type_size_valid(t) ;
 */


/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_BinaryOp
//------------------------------------------------------------------------------
// TODO[MAYBE]: refactor the ztype, xtype, and ytype names to be more descriptive
//              ie. result_type, arg1_type, arg2_type

/*@
 logic void* binaryop_func{L}(GrB_BinaryOp o) = o->function ;
 
 logic int binaryop_code{L}(GrB_BinaryOp o) = o->opcode ;
 
 logic GrB_Type binaryop_ztype{L}(GrB_BinaryOp o) = o->ztype ;
 
 logic GrB_Type binaryop_xtype{L}(GrB_BinaryOp o) = o->xtype ;
 
 logic GrB_Type binaryop_ytype{L}(GrB_BinaryOp o) = o->ytype ;
 
 logic set<char*> binaryop_fp{L}(GrB_BinaryOp o) =
    \union(o,
           ((char*)o->function) + (0..sizeof(o->function)-1),
           o->ztype,
           o->xtype,
           o->ytype) ;
 
 // TODO: check that this is enough to detect init
 predicate binaryop_init{L}(GrB_BinaryOp o) = magic_valid(o->magic) ;
 
 predicate binaryop_code_valid{L}(GrB_BinaryOp o) =
    GB_FIRST_opcode <= binaryop_code(o) <= GB_USER_opcode ;
 
 // used in monoid validity, assumes o is valid binaryop
 // ie. binaryop_valid(o) == \true
 predicate binaryop_domains_same{L}(GrB_BinaryOp o) =
    binaryop_ztype(o) == binaryop_xtype(o) == binaryop_ytype(o) ;
 */

/*@
 // z is the result of the op, x and y are the arguments to the op
 predicate binaryop_valid{L}(GrB_BinaryOp o) =
    \valid(o) &&
    binaryop_init(o) &&
    \valid(((char*)binaryop_func(o)) + (0..sizeof(binaryop_func(o))-1)) &&
    binaryop_code_valid(o) &&
    type_valid(binaryop_ztype(o)) &&
    type_valid(binaryop_xtype(o)) &&
    type_valid(binaryop_ytype(o)) &&
    \separated(binaryop_fp(o)) ;
 */

/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Info
//------------------------------------------------------------------------------

// GrB_Info is an enum type

/*@
 predicate info_valid(GrB_Info i) =
    i == GrB_SUCCESS              ||
    i == GrB_NO_VALUE             ||
    i == GrB_UNINITIALIZED_OBJECT ||
    i == GrB_INVALID_OBJECT       ||
    i == GrB_NULL_POINTER         ||
    i == GrB_INVALID_VALUE        ||
    i == GrB_INVALID_INDEX        ||
    i == GrB_DOMAIN_MISMATCH      ||
    i == GrB_DIMENSION_MISMATCH   ||
    i == GrB_OUTPUT_NOT_EMPTY     ||
    i == GrB_OUT_OF_MEMORY        ||
    i == GrB_INSUFFICIENT_SPACE   ||
    i == GrB_INDEX_OUT_OF_BOUNDS  ||
    i == GrB_PANIC ;
 */

//------------------------------------------------------------------------------
// GrB_Descriptor
//------------------------------------------------------------------------------

// no footprint -- GrB_Desc_Value is an enum type not a pointer type

/*@
 logic GrB_Desc_Value descriptor_output{L}(GrB_Descriptor d) = d->out ;
 
 logic GrB_Desc_Value descriptor_mask{L}(GrB_Descriptor d) = d->mask ;
 
 logic GrB_Desc_Value descriptor_input1{L}(GrB_Descriptor d) = d->in0 ;
 
 logic GrB_Desc_Value descriptor_input2{L}(GrB_Descriptor d) = d->in1 ;
 
 // TODO: check that this is enough to detect init
 predicate descriptor_init{L}(GrB_Descriptor d) = magic_valid(d->magic) ;
 
 // nondefault should be the valid GrB_Desc_Value that v should be
 predicate descriptor_value_valid(GrB_Desc_Value v, GrB_Desc_Value nondefault) =
    v == GxB_DEFAULT || v == nondefault ;
 */

/*@
 predicate descriptor_valid{L}(GrB_Descriptor d) =
    \valid(d) &&
    descriptor_init(d) &&
    descriptor_value_valid(descriptor_output(d), GrB_REPLACE) &&
    descriptor_value_valid(descriptor_mask(d), GrB_SCMP) &&
    descriptor_value_valid(descriptor_input1(d), GrB_TRAN) &&
    descriptor_value_valid(descriptor_input2(d), GrB_TRAN) ;
 */
 
/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Monoid
//------------------------------------------------------------------------------

/*@
 logic GrB_BinaryOp monoid_op{L}(GrB_Monoid m) = m->op ;
 
 logic set<char*> monoid_fp{L}(GrB_Monoid m) =
    \union(m,
           m->op,
           ((char*)m->identity) + (0..(m->op->ztype->size)-1)) ;
 
 // TODO: check that this is enough to detect init
 //       need op or identity to be valid??
 predicate monoid_init{L}(GrB_Monoid m) = magic_valid(m->magic) ;
 */

/*@
 predicate monoid_valid{L}(GrB_Monoid m) =
    \valid(m) &&
    monoid_init(m) &&
    binaryop_valid(monoid_op(m)) &&
    binaryop_domains_same(monoid_op(m)) &&
    \separated(monoid_fp(m)) ;
 */

/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Semiring
//------------------------------------------------------------------------------

/*@
 logic GrB_Monoid semiring_add{L}(GrB_Semiring s) = s->add ;
 
 logic GrB_BinaryOp semiring_mult{L}(GrB_Semiring s) = s->multiply ;
 
 logic set<char*> semiring_fp{L}(GrB_Semiring s) =
    \union(s,
           s->add,
           s->multiply) ;
 
 // TODO: check that this is enough to detect init
 predicate semiring_init{L}(GrB_Semiring s) = magic_valid(s->magic) ;
 */

/*@
 // might expose too much in implementation details
 predicate semiring_valid{L}(GrB_Semiring s) =
    \valid(s) &&
    semiring_init(s) &&
    monoid_valid(semiring_add(s)) &&
    binaryop_valid(semiring_mult(s)) &&
    binaryop_ztype(semiring_mult(s)) ==
        binaryop_ztype(monoid_op(semiring_add(s))) &&
    \separated(semiring_fp(s)) ;
 */

/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Matrix
//------------------------------------------------------------------------------

/*@
 logic int64_t matrix_nrows{L}(GrB_Matrix m) = m->nrows ;
 
 logic int64_t matrix_ncols{L}(GrB_Matrix m) = m->ncols ;
 
 logic int64_t matrix_nvals{L}(GrB_Matrix m) = m->nzmax ;
 
 logic GrB_Type matrix_type{L}(GrB_Matrix m) = m->type ;
 
 logic set<char*> matrix_fp{L}(GrB_Matrix m) =
    \union(m,
           m->type,
           m->p + (0..(m->ncols+1)-1),
           m->i + (0..(m->nzmax)-1),
           ((char*)(m->x + (0..(m->nzmax)-1))) + (0..(m->type->size)-1),
           m->ipending + (0..(m->max_npending)-1),
           m->jpending + (0..(m->max_npending)-1),
           ((char*)(m->xpending + (0..(m->max_npending)-1))) + (0..(m->type->size)-1),
           m->operator_pending,
           (GrB_Matrix)(m->queue_next),
           (GrB_Matrix)(m->queue_prev)) ;
 
 predicate matrix_init{L}(GrB_Matrix m) =
    \valid(m->p + (0..(matrix_ncols(m)+1)-1)) &&
    magic_valid(m->magic) ;
 
 // helper function for row_indices_valid predicate
 logic int64_t unflip(int64_t i) = (i < 0) ? (int64_t)((-i)-2) : i ;
 
 // check row indices in bounds, no duplicates, and ensure sorted
 predicate row_indices_valid{L}(GrB_Matrix m) =
    matrix_init(m)
    &&
    \valid(m->i + (0..(matrix_nvals(m))-1))
    &&
    (\forall int64_t j; 0 <= j < matrix_ncols(m) ==>
        (\forall int64_t p; (m->p)[j] <= p < (m->p)[j+1] ==>
                0 <= unflip((m->i)[p]) < matrix_nrows(m)
        )
        &&
        (\forall int64_t p; (m->p)[j] <= p < (m->p)[j+1]-1 ==>
                unflip((m->i)[p]) < unflip((m->i)[p+1])
        )
    ) ;
 
 // internal predicate to matrix_storage_valid
 // not to be called directly
 predicate pending_tuples_valid{L}(GrB_Matrix m) =
    0 <= m->max_npending
    &&
    0 <= m->npending <= m->max_npending
    &&
    (m->npending == 0 ?
        (m->xpending != \null || m->ipending != \null ||
         m->jpending != \null || m->max_npending != 0 ?
            \false : \true
        ) :
        ((m->xpending == \null || m->ipending == \null ||
         (matrix_ncols(m) > 1 && m->jpending == \null) ?
            \false : \true)
         &&
         \valid(m->ipending + (0..(m->max_npending)-1))
         &&
         \valid(m->jpending + (0..(m->max_npending)-1))
         &&
         tuple_indices_in_bounds :
            (\forall int64_t k; 0 <= k < m->npending ==>
                (\let i = (m->ipending)[k];
                    (\let j = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k]));
                         0 <= i < matrix_nrows(m) &&
                         0 <= j < matrix_ncols(m)
                    )
                )
            )
         &&
         tuple_indices_sorted :
            (m->sorted_pending == \true ?
                (\forall int64_t k; 0 <= k < m->npending-1 ==>
                     (\let ilast = (m->ipending)[k];
                         (\let jlast = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k]));
                             (\let i = (m->ipending)[k+1];
                                 (\let j = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k+1]));
                                    jlast < j || (jlast == j && ilast <= i)
                                 )
                             )
                         )
                     )
                ) :
                !(\forall int64_t k; 0 <= k < m->npending-1 ==>
                    (\let ilast = (m->ipending)[k];
                        (\let jlast = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k]));
                            (\let i = (m->ipending)[k+1];
                                (\let j = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k+1]));
                                    jlast < j || (jlast == j && ilast <= i)
                                )
                            )
                        )
                    )
                 )
            )
         &&
         operator_pending_valid :
            (m->operator_pending == \null ?
                \true :
                \valid(m->operator_pending) && binaryop_valid(m->operator_pending)
            )
        )
    ) ;
 
 // check p, i, x, pix pendings, and zombies
 // TODO [MAYBE]: not checking for correct number of
 //               zombie indices when checking row indices
 // TODO: figure out if should check that x and xpending are \valid?? I think yes
 // TODO: figure out if in col_ptrs_valid should it be j < j+1 instead of j <= j+1??
 // TODO: figure out if in col_ptrs_valid in the if statement is the indexing correct??
 // TODO: fix sorted determination to do strong sorting instead of weak sorting;
 //       0 <= k1 < k2 <= last_index ==> a[k1] < a[k2]
 predicate matrix_storage_valid{L}(GrB_Matrix m) =
    matrix_init(m)
    &&
    (matrix_nvals(m) == 0 ?
        (m->x != \null || m->i != \null || m->i_shallow || m->x_shallow ?
            \false :
            (col_ptrs_valid :
                \forall int64_t j; 0 <= j < matrix_ncols(m) ==> (m->p)[j] == 0
            )
        ) :
        (m->x == \null || m->i == \null ? \false : \true)
    )
    &&
    ((m->p)[0] != 0 ? \false : \true)
    &&
    col_ptrs_valid :
        (\forall int64_t j; 0 <= j < matrix_ncols(m) ==>
            (m->p)[j] <= (m->p)[j+1] <= matrix_nvals(m)
        )
    &&
    0 <= m->nzombies <= (m->p)[matrix_ncols(m)]
    &&
    row_indices_valid(m)
    &&
    pending_tuples_valid(m) ;
 */

/*@
 // nrows, ncols should be >0 by spec, but implementation check says >=0
 predicate matrix_valid{L}(GrB_Matrix m) =
    \valid(m) &&
    0 < matrix_nrows(m) <= \pow(2,60) &&
    0 < matrix_ncols(m) <= \pow(2,60) &&
    0 <= matrix_nvals(m) <= \pow(2,60) &&
    type_valid(matrix_type(m)) &&
    matrix_storage_valid(m) &&
    \separated(matrix_fp(m)) ;
 */

/* TODO: Queue linked list verification -- reachability predicates, etc. -- validity of matrix object linked-list part -- in the queue when it should be, not in the queue when it shouldn't be, etc. to validate other parts of internal rep of matrix
 */

/* TODO: Equality */

//------------------------------------------------------------------------------
// GrB_Vector
//------------------------------------------------------------------------------

/*@
 logic int64_t vector_nrows{L}(GrB_Vector v) = v->nrows ;
 
 logic int64_t vector_ncols{L}(GrB_Vector v) = v->ncols ;
 
 logic int64_t vector_nvals{L}(GrB_Vector v) = v->nzmax ;
 
 logic GrB_Type vector_type{L}(GrB_Vector v) = v->type ;
 
 logic set<char*> vector_fp{L}(GrB_Vector v) = matrix_fp((GrB_Matrix)v) ;
 */

/*@
 predicate vector_valid{L}(GrB_Vector v) =
    matrix_valid((GrB_Matrix)v) &&
    vector_ncols(v) == 1 ;
 */
