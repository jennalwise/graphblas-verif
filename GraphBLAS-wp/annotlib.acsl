//
//  annotlib.acsl
//  
//  SuiteSparse:GraphBLAS:Verification, Jenna L. Wise, (c) 2018, All Rights Reserved.
//  Created on 7/2/18.
//  Last updated on 7/10/18
//  Predicate and logic functions for GrB structs
//  Ensures encapsulation of the structs' internal representation in the annotations

//  IMPORTANT NOTE TO SELF: null ptr checks for input to checks in GB implementation
//                          occur in the check method implementation
//                          I am also doing ptr checks within _valid predicates with
//                          \valid
//                          makes sense since the ptrs are hidden in the typdef

// TODO: Are the {L} labels correct?

#include "GB.h"

//------------------------------------------------------------------------------
// Common
//------------------------------------------------------------------------------

/*@
 predicate magic_valid(int64_t magic) = magic == 0x00981B0787374E72 ;
 */

/*@
 // default is false, because any other cast would be unsound to WP
 predicate void_ptr_valid{L}(void *p, int c) =
    (c == GB_BOOL_code ?
        \valid((bool*)p) :
    (c == GB_INT8_code ?
        \valid((int8_t*)p) :
    (c == GB_UINT8_code ?
        \valid((uint8_t*)p) :
    (c == GB_INT16_code ?
        \valid((int16_t*)p) :
    (c == GB_UINT16_code ?
        \valid((uint16_t*)p) :
    (c == GB_INT32_code ?
        \valid((int32_t*)p) :
    (c == GB_UINT32_code ?
        \valid((uint32_t*)p) :
    (c == GB_INT64_code ?
        \valid((int64_t*)p) :
    (c == GB_UINT64_code ?
        \valid((uint64_t*)p) :
    (c == GB_FP32_code ?
        \valid((float*)p) :
    (c == GB_FP64_code ?
        \valid((double*)p) :
        \false
    ))))))))))) ;
 
 // default is false, because any other cast would be unsound to WP
 predicate void_ptr_array_valid{L}(void *p, int c, int64_t size) =
    (c == GB_BOOL_code ?
        \valid((bool*)p + (0..size-1)) :
    (c == GB_INT8_code ?
        \valid((int8_t*)p + (0..size-1)) :
    (c == GB_UINT8_code ?
        \valid((uint8_t*)p + (0..size-1)) :
    (c == GB_INT16_code ?
        \valid((int16_t*)p + (0..size-1)) :
    (c == GB_UINT16_code ?
        \valid((uint16_t*)p + (0..size-1)) :
    (c == GB_INT32_code ?
        \valid((int32_t*)p + (0..size-1)) :
    (c == GB_UINT32_code ?
        \valid((uint32_t*)p + (0..size-1)) :
    (c == GB_INT64_code ?
        \valid((int64_t*)p + (0..size-1)) :
    (c == GB_UINT64_code ?
        \valid((uint64_t*)p + (0..size-1)) :
    (c == GB_FP32_code ?
        \valid((float*)p + (0..size-1)) :
    (c == GB_FP64_code ?
        \valid((double*)p + (0..size-1)) :
        \false
    ))))))))))) ;
 
 // default is false, because any other cast would be unsound to WP
 // t should be an input type code of the binary operator
 // TODO[ENHANCEMENT]: should also check that the opcode matches the assigned
 //                    function
 predicate void_ptr_binary_function_valid{L}(void *p, int t) =
    (t == GB_BOOL_code ?
        p == &GB_FIRST_f_BOOL || p == &GB_SECOND_f_BOOL || p == &GB_MIN_f_BOOL   ||
        p == &GB_MAX_f_BOOL   || p == &GB_PLUS_f_BOOL   || p == &GB_MINUS_f_BOOL ||
        p == &GB_TIMES_f_BOOL || p == &GB_DIV_f_BOOL    || p == &GB_ISEQ_f_BOOL  ||
        p == &GB_ISNE_f_BOOL  || p == &GB_ISGT_f_BOOL   || p == &GB_ISLT_f_BOOL  ||
        p == &GB_ISGE_f_BOOL  || p == &GB_ISLE_f_BOOL   || p == &GB_LOR_f_BOOL   ||
        p == &GB_LAND_f_BOOL  || p == &GB_LXOR_f_BOOL   || p == &GB_EQ_f_BOOL    ||
        p == &GB_NE_f_BOOL    || p == &GB_GT_f_BOOL     || p == &GB_LT_f_BOOL    ||
        p == &GB_GE_f_BOOL    || p == &GB_LE_f_BOOL     :
    (t == GB_INT8_code ?
        p == &GB_FIRST_f_INT8 || p == &GB_SECOND_f_INT8 || p == &GB_MIN_f_INT8   ||
        p == &GB_MAX_f_INT8   || p == &GB_PLUS_f_INT8   || p == &GB_MINUS_f_INT8 ||
        p == &GB_TIMES_f_INT8 || p == &GB_DIV_f_INT8    || p == &GB_ISEQ_f_INT8  ||
        p == &GB_ISNE_f_INT8  || p == &GB_ISGT_f_INT8   || p == &GB_ISLT_f_INT8  ||
        p == &GB_ISGE_f_INT8  || p == &GB_ISLE_f_INT8   || p == &GB_LOR_f_INT8   ||
        p == &GB_LAND_f_INT8  || p == &GB_LXOR_f_INT8   || p == &GB_EQ_f_INT8    ||
        p == &GB_NE_f_INT8    || p == &GB_GT_f_INT8     || p == &GB_LT_f_INT8    ||
        p == &GB_GE_f_INT8    || p == &GB_LE_f_INT8     :
    (t == GB_UINT8_code ?
        p == &GB_FIRST_f_UINT8 || p == &GB_SECOND_f_UINT8 || p == &GB_MIN_f_UINT8   ||
        p == &GB_MAX_f_UINT8   || p == &GB_PLUS_f_UINT8   || p == &GB_MINUS_f_UINT8 ||
        p == &GB_TIMES_f_UINT8 || p == &GB_DIV_f_UINT8    || p == &GB_ISEQ_f_UINT8  ||
        p == &GB_ISNE_f_UINT8  || p == &GB_ISGT_f_UINT8   || p == &GB_ISLT_f_UINT8  ||
        p == &GB_ISGE_f_UINT8  || p == &GB_ISLE_f_UINT8   || p == &GB_LOR_f_UINT8   ||
        p == &GB_LAND_f_UINT8  || p == &GB_LXOR_f_UINT8   || p == &GB_EQ_f_UINT8    ||
        p == &GB_NE_f_UINT8    || p == &GB_GT_f_UINT8     || p == &GB_LT_f_UINT8    ||
        p == &GB_GE_f_UINT8    || p == &GB_LE_f_UINT8     :
    (t == GB_INT16_code ?
        p == &GB_FIRST_f_INT16 || p == &GB_SECOND_f_INT16 || p == &GB_MIN_f_INT16   ||
        p == &GB_MAX_f_INT16   || p == &GB_PLUS_f_INT16   || p == &GB_MINUS_f_INT16 ||
        p == &GB_TIMES_f_INT16 || p == &GB_DIV_f_INT16    || p == &GB_ISEQ_f_INT16  ||
        p == &GB_ISNE_f_INT16  || p == &GB_ISGT_f_INT16   || p == &GB_ISLT_f_INT16  ||
        p == &GB_ISGE_f_INT16  || p == &GB_ISLE_f_INT16   || p == &GB_LOR_f_INT16   ||
        p == &GB_LAND_f_INT16  || p == &GB_LXOR_f_INT16   || p == &GB_EQ_f_INT16    ||
        p == &GB_NE_f_INT16    || p == &GB_GT_f_INT16     || p == &GB_LT_f_INT16    ||
        p == &GB_GE_f_INT16    || p == &GB_LE_f_INT16     :
    (t == GB_UINT16_code ?
        p == &GB_FIRST_f_UINT16 || p == &GB_SECOND_f_UINT16 || p == &GB_MIN_f_UINT16   ||
        p == &GB_MAX_f_UINT16   || p == &GB_PLUS_f_UINT16   || p == &GB_MINUS_f_UINT16 ||
        p == &GB_TIMES_f_UINT16 || p == &GB_DIV_f_UINT16    || p == &GB_ISEQ_f_UINT16  ||
        p == &GB_ISNE_f_UINT16  || p == &GB_ISGT_f_UINT16   || p == &GB_ISLT_f_UINT16  ||
        p == &GB_ISGE_f_UINT16  || p == &GB_ISLE_f_UINT16   || p == &GB_LOR_f_UINT16   ||
        p == &GB_LAND_f_UINT16  || p == &GB_LXOR_f_UINT16   || p == &GB_EQ_f_UINT16    ||
        p == &GB_NE_f_UINT16    || p == &GB_GT_f_UINT16     || p == &GB_LT_f_UINT16    ||
        p == &GB_GE_f_UINT16    || p == &GB_LE_f_UINT16     :
    (t == GB_INT32_code ?
        p == &GB_FIRST_f_INT32 || p == &GB_SECOND_f_INT32 || p == &GB_MIN_f_INT32   ||
        p == &GB_MAX_f_INT32   || p == &GB_PLUS_f_INT32   || p == &GB_MINUS_f_INT32 ||
        p == &GB_TIMES_f_INT32 || p == &GB_DIV_f_INT32    || p == &GB_ISEQ_f_INT32  ||
        p == &GB_ISNE_f_INT32  || p == &GB_ISGT_f_INT32   || p == &GB_ISLT_f_INT32  ||
        p == &GB_ISGE_f_INT32  || p == &GB_ISLE_f_INT32   || p == &GB_LOR_f_INT32   ||
        p == &GB_LAND_f_INT32  || p == &GB_LXOR_f_INT32   || p == &GB_EQ_f_INT32    ||
        p == &GB_NE_f_INT32    || p == &GB_GT_f_INT32     || p == &GB_LT_f_INT32    ||
        p == &GB_GE_f_INT32    || p == &GB_LE_f_INT32     :
    (t == GB_UINT32_code ?
        p == &GB_FIRST_f_UINT32 || p == &GB_SECOND_f_UINT32 || p == &GB_MIN_f_UINT32   ||
        p == &GB_MAX_f_UINT32   || p == &GB_PLUS_f_UINT32   || p == &GB_MINUS_f_UINT32 ||
        p == &GB_TIMES_f_UINT32 || p == &GB_DIV_f_UINT32    || p == &GB_ISEQ_f_UINT32  ||
        p == &GB_ISNE_f_UINT32  || p == &GB_ISGT_f_UINT32   || p == &GB_ISLT_f_UINT32  ||
        p == &GB_ISGE_f_UINT32  || p == &GB_ISLE_f_UINT32   || p == &GB_LOR_f_UINT32   ||
        p == &GB_LAND_f_UINT32  || p == &GB_LXOR_f_UINT32   || p == &GB_EQ_f_UINT32    ||
        p == &GB_NE_f_UINT32    || p == &GB_GT_f_UINT32     || p == &GB_LT_f_UINT32    ||
        p == &GB_GE_f_UINT32    || p == &GB_LE_f_UINT32     :
    (t == GB_INT64_code ?
        p == &GB_FIRST_f_INT64 || p == &GB_SECOND_f_INT64 || p == &GB_MIN_f_INT64   ||
        p == &GB_MAX_f_INT64   || p == &GB_PLUS_f_INT64   || p == &GB_MINUS_f_INT64 ||
        p == &GB_TIMES_f_INT64 || p == &GB_DIV_f_INT64    || p == &GB_ISEQ_f_INT64  ||
        p == &GB_ISNE_f_INT64  || p == &GB_ISGT_f_INT64   || p == &GB_ISLT_f_INT64  ||
        p == &GB_ISGE_f_INT64  || p == &GB_ISLE_f_INT64   || p == &GB_LOR_f_INT64   ||
        p == &GB_LAND_f_INT64  || p == &GB_LXOR_f_INT64   || p == &GB_EQ_f_INT64    ||
        p == &GB_NE_f_INT64    || p == &GB_GT_f_INT64     || p == &GB_LT_f_INT64    ||
        p == &GB_GE_f_INT64    || p == &GB_LE_f_INT64     :
    (t == GB_UINT64_code ?
        p == &GB_FIRST_f_UINT64 || p == &GB_SECOND_f_UINT64 || p == &GB_MIN_f_UINT64   ||
        p == &GB_MAX_f_UINT64   || p == &GB_PLUS_f_UINT64   || p == &GB_MINUS_f_UINT64 ||
        p == &GB_TIMES_f_UINT64 || p == &GB_DIV_f_UINT64    || p == &GB_ISEQ_f_UINT64  ||
        p == &GB_ISNE_f_UINT64  || p == &GB_ISGT_f_UINT64   || p == &GB_ISLT_f_UINT64  ||
        p == &GB_ISGE_f_UINT64  || p == &GB_ISLE_f_UINT64   || p == &GB_LOR_f_UINT64   ||
        p == &GB_LAND_f_UINT64  || p == &GB_LXOR_f_UINT64   || p == &GB_EQ_f_UINT64    ||
        p == &GB_NE_f_UINT64    || p == &GB_GT_f_UINT64     || p == &GB_LT_f_UINT64    ||
        p == &GB_GE_f_UINT64    || p == &GB_LE_f_UINT64     :
    (t == GB_FP32_code ?
        p == &GB_FIRST_f_FP32 || p == &GB_SECOND_f_FP32 || p == &GB_MIN_f_FP32   ||
        p == &GB_MAX_f_FP32   || p == &GB_PLUS_f_FP32   || p == &GB_MINUS_f_FP32 ||
        p == &GB_TIMES_f_FP32 || p == &GB_DIV_f_FP32    || p == &GB_ISEQ_f_FP32  ||
        p == &GB_ISNE_f_FP32  || p == &GB_ISGT_f_FP32   || p == &GB_ISLT_f_FP32  ||
        p == &GB_ISGE_f_FP32  || p == &GB_ISLE_f_FP32   || p == &GB_LOR_f_FP32   ||
        p == &GB_LAND_f_FP32  || p == &GB_LXOR_f_FP32   || p == &GB_EQ_f_FP32    ||
        p == &GB_NE_f_FP32    || p == &GB_GT_f_FP32     || p == &GB_LT_f_FP32    ||
        p == &GB_GE_f_FP32    || p == &GB_LE_f_FP32     :
    (t == GB_FP64_code ?
        p == &GB_FIRST_f_FP64 || p == &GB_SECOND_f_FP64 || p == &GB_MIN_f_FP64   ||
        p == &GB_MAX_f_FP64   || p == &GB_PLUS_f_FP64   || p == &GB_MINUS_f_FP64 ||
        p == &GB_TIMES_f_FP64 || p == &GB_DIV_f_FP64    || p == &GB_ISEQ_f_FP64  ||
        p == &GB_ISNE_f_FP64  || p == &GB_ISGT_f_FP64   || p == &GB_ISLT_f_FP64  ||
        p == &GB_ISGE_f_FP64  || p == &GB_ISLE_f_FP64   || p == &GB_LOR_f_FP64   ||
        p == &GB_LAND_f_FP64  || p == &GB_LXOR_f_FP64   || p == &GB_EQ_f_FP64    ||
        p == &GB_NE_f_FP64    || p == &GB_GT_f_FP64     || p == &GB_LT_f_FP64    ||
        p == &GB_GE_f_FP64    || p == &GB_LE_f_FP64     :
        \false
    ))))))))))) ;
*/


// Separation predicates between different structs/objects/ptrs
// (not separation of their internal footprints -- see corresponding
// struct/object section below for separation predicates which determine
// if a/an struct/object's footprint is separated).
// These predicates are written as needed.
// Forced to do this, this way, because WP doesn't support heterogenuous casts
// of pointers at this time and to ensure ecapsulation of structs'/objects' internal
// representations.

/* TODO: write separation predicates as I annotate methods/bfs app */

//------------------------------------------------------------------------------
// GrB_Type
//------------------------------------------------------------------------------

// no footprint
/*@
 logic int type_code{L}(GrB_Type t) = t->code ;
 
 logic size_t type_size{L}(GrB_Type t) = t->size ;
 
 predicate type_init{L}(GrB_Type t) = magic_valid(t->magic) ;
 
 predicate type_code_valid{L}(GrB_Type t) =
    \let c = type_code(t);
        c == GB_BOOL_code   ||
        c == GB_INT8_code   ||
        c == GB_UINT8_code  ||
        c == GB_INT16_code  ||
        c == GB_UINT16_code ||
        c == GB_INT32_code  ||
        c == GB_UINT32_code ||
        c == GB_INT64_code  ||
        c == GB_UINT64_code ||
        c == GB_FP32_code   ||
        c == GB_FP64_code   ||
        c == GB_UDT_code ;
 
 predicate type_size_valid{L}(GrB_Type t) =
    type_size(t) != 0 &&
    (\let c = type_code(t);
        (\let s = type_size(t);
            (c == GB_BOOL_code ?
                s == sizeof(bool) :
            (c == GB_INT8_code ?
                s == sizeof(int8_t) :
            (c == GB_UINT8_code ?
                s == sizeof(uint8_t) :
            (c == GB_INT16_code ?
                s == sizeof(int16_t) :
            (c == GB_UINT16_code ?
                s == sizeof(uint16_t) :
            (c == GB_INT32_code ?
                s == sizeof(int32_t) :
            (c == GB_UINT32_code ?
                s == sizeof(uint32_t) :
            (c == GB_INT64_code ?
                s == sizeof(int64_t) :
            (c == GB_UINT64_code ?
                s == sizeof(uint64_t) :
            (c == GB_FP32_code ?
                s == sizeof(float) :
            (c == GB_FP64_code ?
                s == sizeof(double) :
            (c == GB_UDT_code ?
                s == s :
                \false
            ))))))))))))
        )
    ) ;
 */

/*@
 predicate type_valid{L}(GrB_Type t) =
    \valid(t) &&
    type_init(t) &&
    type_code_valid(t) &&
    type_size_valid(t) ;
 */


/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_BinaryOp
//------------------------------------------------------------------------------

/*@
 logic void* binaryop_func{L}(GrB_BinaryOp o) = o->function ;
 
 logic int binaryop_code{L}(GrB_BinaryOp o) = o->opcode ;
 
 logic GrB_Type binaryop_outtype{L}(GrB_BinaryOp o) = o->ztype ;
 
 logic GrB_Type binaryop_in1type{L}(GrB_BinaryOp o) = o->xtype ;
 
 logic GrB_Type binaryop_in2type{L}(GrB_BinaryOp o) = o->ytype ;
 
 predicate binaryop_init{L}(GrB_BinaryOp o) = magic_valid(o->magic) ;
 
 predicate binaryop_code_valid{L}(GrB_BinaryOp o) =
    GB_FIRST_opcode <= binaryop_code(o) <= GB_USER_opcode ;
 
 // used in monoid validity, assumes o is valid binaryop
 // ie. binaryop_valid(o) == \true
 predicate binaryop_domains_same{L}(GrB_BinaryOp o) =
    binaryop_outtype(o) == binaryop_in1type(o) == binaryop_in2type(o) ;
 
 predicate binaryop_fp_separated{L}(GrB_BinaryOp o) =
    \separated(o,
               ((char*)o->function) + (0..sizeof(o->function)-1),
               o->ztype,
               o->xtype,
               o->ytype) ;
 */

/*@
 predicate binaryop_valid{L}(GrB_BinaryOp o) =
    \valid(o) &&
    binaryop_init(o) &&
    binaryop_code_valid(o) &&
    type_valid(binaryop_outtype(o)) &&
    type_valid(binaryop_in1type(o)) &&
    type_valid(binaryop_in2type(o)) &&
    void_ptr_binary_function_valid(binaryop_func(o),type_code(binaryop_in1type(o))) &&
    binaryop_fp_separated(o) ;
 */

/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Info
//------------------------------------------------------------------------------

// GrB_Info is an enum type

/*@
 predicate info_valid(GrB_Info i) =
    i == GrB_SUCCESS              ||
    i == GrB_NO_VALUE             ||
    i == GrB_UNINITIALIZED_OBJECT ||
    i == GrB_INVALID_OBJECT       ||
    i == GrB_NULL_POINTER         ||
    i == GrB_INVALID_VALUE        ||
    i == GrB_INVALID_INDEX        ||
    i == GrB_DOMAIN_MISMATCH      ||
    i == GrB_DIMENSION_MISMATCH   ||
    i == GrB_OUTPUT_NOT_EMPTY     ||
    i == GrB_OUT_OF_MEMORY        ||
    i == GrB_INSUFFICIENT_SPACE   ||
    i == GrB_INDEX_OUT_OF_BOUNDS  ||
    i == GrB_PANIC ;
 */

//------------------------------------------------------------------------------
// GrB_Descriptor
//------------------------------------------------------------------------------

// no footprint -- GrB_Desc_Value is an enum type not a pointer type

/*@
 logic GrB_Desc_Value descriptor_output{L}(GrB_Descriptor d) = d->out ;
 
 logic GrB_Desc_Value descriptor_mask{L}(GrB_Descriptor d) = d->mask ;
 
 logic GrB_Desc_Value descriptor_input0{L}(GrB_Descriptor d) = d->in0 ;
 
 logic GrB_Desc_Value descriptor_input1{L}(GrB_Descriptor d) = d->in1 ;
 
 predicate descriptor_init{L}(GrB_Descriptor d) = magic_valid(d->magic) ;
 
 // nondefault should be the valid nondefault GrB_Desc_Value that v should be
 predicate descriptor_value_valid(GrB_Desc_Value v, GrB_Desc_Value nondefault) =
    v == GxB_DEFAULT || v == nondefault ;
 */

/*@
 predicate descriptor_valid{L}(GrB_Descriptor d) =
    \valid(d) &&
    descriptor_init(d) &&
    descriptor_value_valid(descriptor_output(d), GrB_REPLACE) &&
    descriptor_value_valid(descriptor_mask(d), GrB_SCMP) &&
    descriptor_value_valid(descriptor_input0(d), GrB_TRAN) &&
    descriptor_value_valid(descriptor_input1(d), GrB_TRAN) ;
 */
 
/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Monoid
//------------------------------------------------------------------------------

/* TODO: specification validity for monoid not already checked - binaryop is
         associative, identity is in fact an identity element of the binaryop &
         domain, other algebraic properties of a monoid not checked
 
   TODO: determine whether it is possible to check whether an identity's bits are
         all zero without performing unsound pointer casts
 */

/*@
 logic GrB_BinaryOp monoid_op{L}(GrB_Monoid m) = m->op ;
 
 logic void* monoid_identity{L}(GrB_Monoid m) = m->identity ;
 
 predicate monoid_init{L}(GrB_Monoid m) = magic_valid(m->magic) ;
 
 // DO NOT CALL THIS FUNCTION UNLESS PERFORMING VALUE ANALYSIS BEFORE WP
 // WP Typed+cast WILL BE UNSOUND AND Typed ALONE WILL FAIL
 // assumes the monoid's binary op is valid,
 // ie. binaryop_valid(monoid_op(m)) == \true
 // assumes the monoid's identity element can be deferenced
 // internal predicate of monoid_valid
 predicate identity_is_zero_bool_valid{L}(GrB_Monoid m) =
    (m->identity_is_zero == \true ?
        (\let i = (int8_t*)monoid_identity(m);
            (\forall int64_t k; 0 <= k < type_size(binaryop_outtype(monoid_op(m)))
                ==> i[k] == 0
            )
        ) :
        !(\let i = (int8_t*)monoid_identity(m);
            (\forall int64_t k; 0 <= k < type_size(binaryop_outtype(monoid_op(m)))
                ==> i[k] == 0
            )
         )
    ) ;
 
 predicate monoid_fp_separated{L}(GrB_Monoid m) =
    \separated(m,
               m->op,
               ((char*)m->identity) + (0..(m->op->ztype->size)-1)) ;
 */

/*@
 predicate monoid_valid{L}(GrB_Monoid m) =
    \valid(m) &&
    monoid_init(m) &&
    binaryop_valid(monoid_op(m)) &&
    binaryop_domains_same(monoid_op(m)) &&
    void_ptr_valid(monoid_identity(m),type_code(binaryop_outtype(monoid_op(m)))) &&
    monoid_fp_separated(m) ;
 */

/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Semiring
//------------------------------------------------------------------------------

/* TODO: check that a valid semiring's monoid is commutative */

/*@
 logic GrB_Monoid semiring_monoid{L}(GrB_Semiring s) = s->add ;
 
 // assumes that s->add is a valid monoid, ie. monoid_valid(s->add) == \true
 logic GrB_BinaryOp semiring_add{L}(GrB_Semiring s) = s->add->op ;
 
 logic GrB_BinaryOp semiring_mult{L}(GrB_Semiring s) = s->multiply ;
 
 predicate semiring_init{L}(GrB_Semiring s) = magic_valid(s->magic) ;
 
 predicate semiring_fp_separated{L}(GrB_Semiring s) =
    \separated(s,
               s->add,
               s->multiply) ;
 */

/*@
 // might expose too much in implementation details
 predicate semiring_valid{L}(GrB_Semiring s) =
    \valid(s) &&
    semiring_init(s) &&
    monoid_valid(semiring_monoid(s)) &&
    binaryop_valid(semiring_mult(s)) &&
    binaryop_outtype(semiring_mult(s)) ==
        binaryop_outtype(semiring_add(s)) &&
    semiring_fp_separated(s) ;
 */

/* TODO[MAYBE]: Equality */

//------------------------------------------------------------------------------
// GrB_Matrix
//------------------------------------------------------------------------------

/*@
 logic int64_t matrix_nrows{L}(GrB_Matrix m) = m->nrows ;
 
 logic int64_t matrix_ncols{L}(GrB_Matrix m) = m->ncols ;
 
 logic int64_t matrix_nvals{L}(GrB_Matrix m) = m->nzmax ;
 
 logic GrB_Type matrix_type{L}(GrB_Matrix m) = m->type ;
 
 predicate matrix_init{L}(GrB_Matrix m) = magic_valid(m->magic) ;
 
 // helper function for row_indices_valid predicate
 logic int64_t unflip(int64_t i) = (i < 0) ? (int64_t)((-i)-2) : i ;
 
 // check row indices in bounds, no duplicates, and ensure sorted
 predicate row_indices_valid{L}(GrB_Matrix m) =
    \valid(m->p + (0..(matrix_ncols(m)+1)-1))
    &&
    \valid(m->i + (0..(matrix_nvals(m))-1))
    &&
    (\forall int64_t j; 0 <= j < matrix_ncols(m) ==>
        in_bounds :
            (\forall int64_t p; (m->p)[j] <= p < (m->p)[j+1] ==>
                0 <= unflip((m->i)[p]) < matrix_nrows(m)
            )
        &&
        sorted_no_dups :
            (\forall int64_t p; (m->p)[j] <= p < (m->p)[j+1]-1 ==>
                unflip((m->i)[p]) < unflip((m->i)[p+1])
            )
    ) ;
 
 // internal predicate to matrix_storage_valid
 // not to be called directly
 predicate pending_tuples_valid{L}(GrB_Matrix m) =
    0 <= m->max_npending
    &&
    0 <= m->npending <= m->max_npending
    &&
    (m->npending == 0 ?
        (m->xpending != \null || m->ipending != \null ||
         m->jpending != \null || m->max_npending != 0 ?
            \false : \true
        ) :
        ((m->xpending == \null || m->ipending == \null ||
         (matrix_ncols(m) > 1 && m->jpending == \null) ?
            \false : \true)
         &&
         \valid(m->ipending + (0..(m->max_npending)-1))
         &&
         \valid(m->jpending + (0..(m->max_npending)-1))
         &&
         void_ptr_array_valid(m->xpending,type_code(matrix_type(m)),m->max_npending)
         &&
         tuple_indices_in_bounds :
            (\forall int64_t k; 0 <= k < m->npending ==>
                (\let i = (m->ipending)[k];
                    (\let j = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k]));
                         0 <= i < matrix_nrows(m) &&
                         0 <= j < matrix_ncols(m)
                    )
                )
            )
         &&
         tuple_indices_sorted :
            (m->sorted_pending == \true ?
                (\forall int64_t k; 0 <= k < m->npending-1 ==>
                     (\let ilast = (m->ipending)[k];
                         (\let jlast = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k]));
                             (\let i = (m->ipending)[k+1];
                                 (\let j = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k+1]));
                                    jlast < j || (jlast == j && ilast <= i)
                                 )
                             )
                         )
                     )
                ) :
                !(\forall int64_t k; 0 <= k < m->npending-1 ==>
                    (\let ilast = (m->ipending)[k];
                        (\let jlast = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k]));
                            (\let i = (m->ipending)[k+1];
                                (\let j = (matrix_ncols(m) <= 1 ? 0 : ((m->jpending)[k+1]));
                                    jlast < j || (jlast == j && ilast <= i)
                                )
                            )
                        )
                    )
                 )
            )
         &&
         operator_pending_valid :
            (m->operator_pending == \null ?
                \true :
                binaryop_valid(m->operator_pending)
            )
        )
    ) ;
 
 // check p, i, x, pix pendings, and zombies
 predicate matrix_storage_valid{L}(GrB_Matrix m) =
    \valid(m->p + (0..(matrix_ncols(m)+1)-1))
    &&
    (matrix_nvals(m) == 0 ?
        (m->x != \null || m->i != \null || m->i_shallow || m->x_shallow ?
            \false :
            (col_ptrs_valid :
                \forall int64_t j; 0 <= j < matrix_ncols(m) ==> (m->p)[j] == 0
            )
        ) :
        (m->x == \null || m->i == \null ?
            \false :
            ((m->p)[0] != 0 ? \false : \true)
            &&
            col_ptrs_valid :
                (\forall int64_t j; 0 <= j < matrix_ncols(m) ==>
                    (m->p)[j] <= (m->p)[j+1] <= matrix_nvals(m)
                )
            &&
            void_ptr_array_valid(m->x,type_code(matrix_type(m)),matrix_nvals(m))
            &&
            row_indices_valid(m)
        )
    )
    &&
    0 <= m->nzombies <= (m->p)[matrix_ncols(m)]
    &&
    pending_tuples_valid(m) ;
 
 predicate matrix_fp_separated{L}(GrB_Matrix m) =
    \separated(m,
               m->type,
               m->p + (0..(m->ncols+1)-1),
               m->i + (0..(m->nzmax)-1),
               ((char*)(m->x + (0..(m->nzmax)-1))) + (0..(m->type->size)-1),
               m->ipending + (0..(m->max_npending)-1),
               m->jpending + (0..(m->max_npending)-1),
               ((char*)(m->xpending + (0..(m->max_npending)-1))) + (0..(m->type->size)-1),
               m->operator_pending,
               ((char*)m->queue_next) + (0..sizeof(GrB_Matrix)-1),
               ((char*)m->queue_prev) + (0..sizeof(GrB_Matrix)-1)) ;
 */

/*@
 // nrows, ncols should be >0 by spec, but implementation check says >=0
 predicate matrix_valid{L}(GrB_Matrix m) =
    \valid(m) &&
    matrix_init(m) &&
    0 < matrix_nrows(m) <= \pow(2,60) &&
    0 < matrix_ncols(m) <= \pow(2,60) &&
    0 <= matrix_nvals(m) <= \pow(2,60) &&
    type_valid(matrix_type(m)) &&
    matrix_storage_valid(m) &&
    matrix_fp_separated(m) ;
 */

/* TODO: Queue linked list verification -- reachability predicates, etc.
         -- validity of matrix object linked-list part -- in the queue when it
         should be, not in the queue when it shouldn't be, etc. to validate other
         parts of internal rep of matrix
 */

/* TODO [MAYBE]: not checking for correct number of zombie indices when checking
                 row indices requires ghost code -- for matrix valid
 */

/* TODO: Equality */

//------------------------------------------------------------------------------
// GrB_Vector
//------------------------------------------------------------------------------

/*@
 logic int64_t vector_nrows{L}(GrB_Vector v) = v->nrows ;
 
 logic int64_t vector_ncols{L}(GrB_Vector v) = v->ncols ;
 
 logic int64_t vector_nvals{L}(GrB_Vector v) = v->nzmax ;
 
 logic GrB_Type vector_type{L}(GrB_Vector v) = v->type ;
 */

/*@
 predicate vector_valid{L}(GrB_Vector v) =
    matrix_valid((GrB_Matrix)v) &&
    vector_ncols(v) == 1 ;
 */
